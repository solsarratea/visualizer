<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>05 - Game of Life </title>
  <meta charset="utf-8">
  <title>Game of Life Visualizer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
  <meta name="description" content="visualizing shaders with three.js experiment">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
    integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">
  <link href="/core/public/styles.css" rel="stylesheet">
  <script src="/core/js/utils.js"></script>
</head>

<body>
  <a id="btn" class="info">
    <span class="fab fas fa-info-circle info"></span>
  </a>
  <div id="showInfo" class="modal">
    <div class="modal-header">
      <p>GAME OF LIFE</p>
      <span class="close">&times;
      </span>
    </div>
    <div class="modal-content">
      <h4>
        This is an implementation of John Conway's Game of Life</a> on Three.js and WebGL that allows pattern formation in video capture.
      </h4>
      <p>On the right side: Open Controls</p>
    </div>

  </div>
  </div>
  <a href="https://github.com/solsarratea/visualizer/tree/master/04-gray-scott" class="info"
    title="View source on Github">
    <span class="fab fa-github"></span>
    <span class="text">View source</span>
  </a>

  <body>
    <video id="video" autoplay="" style="display:none"></video>
    <script type="x-shader/x-fragment" id="fragShader">
      uniform int timer;
      uniform vec2 resolution;
      uniform vec2 mouse;
      uniform sampler2D texture;
      uniform sampler2D start;
      vec2 pos;
      vec2 texColor;
      vec2 offset;
      uniform float pixelSize;
      uniform float t;
      uniform float threshold;
      uniform float bound;
      uniform float rNeighbour;
      uniform float tNeighbour;
      uniform bool remember;
      uniform bool travel;


      void main( void ){
         
         pos = vec2(
           floor( gl_FragCoord.x / pixelSize ) * pixelSize + pixelSize * t,
           floor( gl_FragCoord.y / pixelSize ) * pixelSize + pixelSize * t
         );

        vec3 color = texture2D( texture, pos / resolution ).rgb;

        if (remember){
          color.g = color.r;
        };

        if (travel){
          color.r = color.g;
          color.g = 0.;

        } else {

         vec2 dy = floor(rNeighbour * vec2(1.,-1.) + tNeighbour)* pixelSize /resolution.xy; 
         vec2 dx = floor(rNeighbour * vec2(1.,-1.) + tNeighbour)* pixelSize /resolution.xy;
         vec2 pixel = pos / resolution.xy;

         float neighbors = 0.0;
         vec4 N = texture2D(texture, vec2(pixel.x, pixel.y + dy.x));
        neighbors += step(threshold,N.r);
         vec4 S = texture2D(texture, vec2(pixel.x, pixel.y + dy.y));
         neighbors += step(threshold,S.r);
         vec4 W = texture2D(texture, vec2(pixel.x + dx.x, pixel.y));
        neighbors += step(threshold,W.r);
         vec4 E = texture2D(texture, vec2(pixel.x + dx.y, pixel.y));
        neighbors += step(threshold,E.r);
 
         vec4 NE = texture2D(texture, vec2(pixel.x + dx.x, pixel.y + dy.x));
        neighbors += step(threshold,NE.r);
         vec4 NW = texture2D(texture, vec2(pixel.x + dx.y, pixel.y + dy.x));
        neighbors += step(threshold,NW.r);
         vec4 SE = texture2D(texture, vec2(pixel.x + dx.x, pixel.y + dy.y));
        neighbors += step(threshold,SE.r);
         vec4 SW = texture2D(texture, vec2(pixel.x + dx.y, pixel.y + dy.y));
        neighbors += step(threshold,SW.r);

       // neighbors = N.r + S.r + E.r + W.r + NE.r + NW.r + SE.r +SW.r;


        float status = step(threshold, color.r );
        if (status == 1.0 && neighbors > bound ){
          color = vec3(0.5, color.g, color.b);
        }else if( status == 1.0 && ( neighbors <= 1.0 )){
           color = vec3(0.5, color.g, color.b);
         }
         else if( status == 0.0 && neighbors == bound ){
           color = vec3(1., color.g, color.b);
         }
         else if( floor(pos / (pixelSize*2.0)) == floor(mouse / (pixelSize*2.0)) ){
           color =vec3(1.);
         } else color = vec3(status, color.g, color.b);

        }
  
        gl_FragColor = vec4(color,1.);

        
        }
    </script>
    <script id="vertexShader" type="x-shader/x-vertex">
       varying vec2 texCoordVarying;
   
       void main() {
           gl_Position =  vec4(position,1.0);
       }
    </script>
    <script type="x-shader/x-fragment" id="color">
      uniform vec2 resolution;
      uniform sampler2D texture;
      uniform sampler2D start;
      uniform vec3 color1;
      uniform vec3 color2;
      uniform float activate;

      void main( void ){
         vec2 uv = gl_FragCoord.xy / resolution;
         vec3 color3 = texture2D(start, uv).rgb;
         
         vec4 newColor = vec4( mix( 
             color1,
             (color2 * (1.-activate) + color3 * activate) ,
             texture2D( texture, uv ).r), 1.0);

         gl_FragColor = newColor ;
         //+ 0.1* vec4(1.-color3,1.);
      }
     </script>
     <script src="/core/js/utils.js"></script>
    <script src="/core/js/index-controls.js"></script>
    <script src="../dist/gol.bundle.js"></script> <!-- Use in production -->
    <!-- <script src="http://localhost:9001/dist/gsvideo.bundle.js"></script> -->
    <!-- Use in development -->
  </body>

</html>